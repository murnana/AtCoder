using SourceExpander;

internal sealed class Program
{
    /// <summary>
    /// AtCoder Beginner Contest 429
    /// C - Odd One Subsequence
    /// 🤖 本プログラムはClaude Code (claude.ai/code) の支援により作成されました
    /// </summary>
    /// <remarks>
    /// 【問題概要】
    /// 長さNの整数列Aが与えられる。1≤i&lt;j&lt;k≤Nを満たす組(i,j,k)のうち、
    /// A_i, A_j, A_kの中にちょうど2種類の値が含まれるものの個数を求める。
    ///
    /// 【解法のポイント - 公式解説のO(N)解法】
    /// - 「ちょうど2種類」= 3つのうち2つが同じ値x、1つが異なる値
    /// - 各値xに注目して、「xがちょうど2個含まれる3つ組」を数える
    /// - B_x = 配列内でxが出現する回数とすると:
    ///   C_x = (xから2個選ぶ) × (非xから1個選ぶ)
    ///       = C(B_x, 2) × (N - B_x)
    ///       = B_x × (B_x - 1) / 2 × (N - B_x)
    /// - 答え = Σ C_x (すべてのxについて)
    ///
    /// 【計算量】
    /// - 時間計算量: O(N)
    ///   - 頻度のカウント: O(N)
    ///   - 各値の計算: O(N) (最大N種類)
    /// - 空間計算量: O(N)
    ///   - 頻度配列: O(N)
    ///
    /// 【実装の利点】
    /// - 組み合わせの数学的性質を利用してO(N)で解決
    /// - 1 ≤ A_i ≤ N という制約を活かし配列で高速化
    /// - 類似問題: 頻度ベースの組み合わせ計算問題に応用可能
    /// </remarks>
    /// <seealso href="https://atcoder.jp/contests/abc429/tasks/abc429_c" />
    /// <seealso href="https://atcoder.jp/contests/abc429/editorial/14283" />
    /// <seealso href="https://atcoder.jp/contests/abc429/submissions/70486173" />
    private static void Main()
    {
        Expander.Expand();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // ステップ1: 入力読み込み
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        var N = int.Parse(s: Console.ReadLine());
        var A = new int[N];
        {
            var line = Console.ReadLine().Split(separator: ' ');
            for(var i = 0; i < N; i++)
            {
                A[i] = int.Parse(s: line[i]);
            }
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // ステップ2: 各値の出現頻度をカウント
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 【解法の核心】
        // 「ちょうど2種類の値を含む3つ組」は、次のように言い換えられる:
        //   → 「ある値xが2個、別の値yが1個含まれる3つ組」
        //
        // 例: A = [1, 2, 1, 3, 1] の場合
        //   freq[1] = 3, freq[2] = 1, freq[3] = 1
        //
        // 制約 1 ≤ A_i ≤ N を利用して、配列で高速にカウント (O(1)アクセス)
        var freq = new int[N + 1];
        for(var i = 0; i < N; i++)
        {
            freq[A[i]]++;
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // ステップ3: 組み合わせ論で答えを計算
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 【組み合わせの分解】
        // 各値xについて、「xが2個、非xが1個」となる3つ組の数を計算:
        //
        //   C_x = (xから2個選ぶ方法) × (非xから1個選ぶ方法)
        //       = C(B_x, 2) × (N - B_x)
        //       = [B_x × (B_x - 1) / 2] × (N - B_x)
        //
        // 【具体例】freq[1] = 3, N = 5 の場合:
        //   - 1から2個選ぶ: C(3, 2) = 3通り (例: 位置0と位置2、位置0と位置4、...)
        //   - 非1から1個選ぶ: 5 - 3 = 2個 (2と3が各1個ずつ)
        //   → C_1 = 3 × 2 = 6通り
        //
        // 全てのxについてこれを合計すれば、求める答えが得られる
        long answer = 0;
        for(var x = 1; x <= N; x++)
        {
            var Bx = freq[x];

            // Bx >= 2 でないと「2個選ぶ」ことができない
            if(Bx >= 2)
            {
                // xから2個選ぶ組み合わせ数: C(B_x, 2) = B_x! / (2! × (B_x-2)!)
                //                                      = B_x × (B_x - 1) / 2
                var pairsOfX = (long)Bx * (Bx - 1) / 2;

                // 非xの要素数 (これが「1個選ぶ」対象の総数)
                var nonX = N - Bx;

                // この値xが貢献する3つ組の数を加算
                // 【数学的な意味】pairsOfX個の「xのペア」それぞれに対し、
                // nonX個の「非x」をどれか1つ追加できる
                answer += pairsOfX * nonX;
            }
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // ステップ4: 結果出力
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        Console.WriteLine(value: answer);
    }
}
