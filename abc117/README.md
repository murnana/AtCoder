# AtCoder Beginner Contest 117

会場: https://atcoder.jp/contests/abc117
公式解説放送: https://youtu.be/OOtz0Lx_mRk

自分の提出: https://atcoder.jp/contests/abc117/submissions?f.User=murnana


## 参加後実績

|                    |      |
| -----------------: | :--- |
|               順位 | -    |
|             Rating | -    |
|       Rating最高値 | -    |
| コンテスト参加回数 | -    |




## 解けなかった問題の解説メモ

### C-Streamline

https://atcoder.jp/contests/abc117/tasks/abc117_c

- コストが低い者同士をグループ化する
- グループは、コマの数だけ作る(=どのコマがどのグループを担当するかを決めたい)
- では、このグループをどのように作るか、が問題
- 区切るとこは、移動コストが最も大きい座標から区切る
- そうすると、一番大きい座標の移動がなくなるので、最終的なコストが減る


最適解:
  1. N,M,Xを取得
  2. Xを昇順にソート
  3. XとXの間の距離dを作り、dを昇順ソート
  4. dの末尾(N-1番目)を削除
  5. 残ったdの和が答え



### D - XXOR

https://atcoder.jp/contests/abc117/tasks/abc117_d

(D問題そもそも見てない ><)

- 数字を2進数で考える
- 1桁ごとに最大数を考えた場合  
  1が多いか、0が多いかによってXORの値を変える必要がある
  - 1が多い場合はそのままにしたい
  - 0が多い場合はビット反転させたい
- ただし、この **XORはKより上は🙅** という制約がある!!
  - なかったらビットたて放題や…
  - どの桁のビットが立ったときに制約を気にする必要があるのかを知る必要がある
- この制約のため、 **最大桁から順にKと一致しているビット** がある場合は探査しなければならない
  - Kのある桁をK[i]、XORの値をXとし、その桁をX[i]とすると
  - 最大桁数から探索して**K[i]=0なのにX[i]=1になると🙅**
    - X[i]を0にして終了❓
  - 逆に **K[i]=1なのにX[i]=0の場合は、その後探索する必要がない** 貪欲になれる
  - K[i] == X[i]の場合は探索続行
